<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>UT 完成版（原点① 精密反射）</title>

<style>
body{
  background:#111;
  color:white;
  font-family:sans-serif;
  margin:0;
  padding:10px;
}
.controls{
  display:flex;
  flex-direction:column;
  gap:10px;
}
input{
  font-size:18px;
  padding:6px;
}
canvas{
  background:#222;
  width:100%;
  height:auto;
  border-radius:8px;
  margin-top:10px;
}
</style>
</head>
<body>

<div class="controls">
板厚(mm)
<input type="number" id="thickness" value="12" step="0.1" oninput="draw()">

探触子位置X(mm)
<input type="number" id="probeX" value="20" step="0.1" oninput="draw()">

角度(°) ※垂直基準
<input type="number" id="angle" value="60" step="0.1" oninput="draw()">

ビーム経路長(mm)
<input type="number" id="pathLength" value="40" step="0.1" oninput="draw()">
</div>

<canvas id="canvas" width="600" height="420"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const scale = 8;
const gap = 6;

// 原点＝上面 × ルート左端
const originX = 260;
const originY = 140;

function draw(){

ctx.clearRect(0,0,canvas.width,canvas.height);

const t = parseFloat(document.getElementById("thickness").value);
const probe = parseFloat(document.getElementById("probeX").value);
const angleDeg = parseFloat(document.getElementById("angle").value);
const pathLength = parseFloat(document.getElementById("pathLength").value);

const angleRad = angleDeg * Math.PI / 180;
const bottomY = originY + t*scale;

// ===== 図面 =====
ctx.strokeStyle="red";
ctx.lineWidth=2;

// 左柱
ctx.beginPath();
ctx.moveTo(originX-120,40);
ctx.lineTo(originX-120,380);
ctx.stroke();

// 原点縦線
ctx.beginPath();
ctx.moveTo(originX,40);
ctx.lineTo(originX,380);
ctx.stroke();

// 上面
ctx.beginPath();
ctx.moveTo(originX,originY);
ctx.lineTo(580,originY);
ctx.stroke();

// 底面
ctx.beginPath();
ctx.moveTo(originX,bottomY);
ctx.lineTo(580,bottomY);
ctx.stroke();

// ルート6mm（底面）
ctx.strokeStyle="white";
ctx.lineWidth=4;
ctx.beginPath();
ctx.moveTo(originX,bottomY);
ctx.lineTo(originX+gap*scale,bottomY);
ctx.stroke();

// 60°開先（右上）
ctx.strokeStyle="yellow";
ctx.lineWidth=2;

let rise = t*scale;
let run = rise/Math.tan(60*Math.PI/180);

ctx.beginPath();
ctx.moveTo(originX+gap*scale,bottomY);
ctx.lineTo(originX+gap*scale+run,bottomY-rise);
ctx.stroke();

// ===== ビーム（垂直基準・左下・精密反射）=====
let currentX = originX + probe*scale;
let currentY = originY;

let remaining = pathLength*scale;

let dx = -Math.sin(angleRad);
let dy =  Math.cos(angleRad);

ctx.strokeStyle="cyan";
ctx.lineWidth=2;
ctx.beginPath();
ctx.moveTo(currentX,currentY);

for(let i=0;i<2;i++){

  let targetY = dy > 0 ? bottomY : originY;
  let travel = (targetY - currentY) / dy;

  if(remaining <= travel){
    currentX += dx * remaining;
    currentY += dy * remaining;
    ctx.lineTo(currentX,currentY);
    break;
  }

  // 正確にヒット位置へ吸着
  currentX += dx * travel;
  currentY = targetY;

  ctx.lineTo(currentX,currentY);

  remaining -= travel;
  dy = -dy; // 反射
}

ctx.stroke();

// 欠陥点
ctx.beginPath();
ctx.arc(currentX,currentY,6,0,Math.PI*2);
ctx.fillStyle="cyan";
ctx.fill();

// 座標表示（原点基準）
let defectXmm = (currentX-originX)/scale;
let defectYmm = (currentY-originY)/scale;

ctx.fillStyle="white";
ctx.font="16px sans-serif";
ctx.fillText(
"X: "+defectXmm.toFixed(1)+" mm   Y: "+defectYmm.toFixed(1)+" mm",
20,
30
);

}

draw();
</script>

</body>
</html>
